Initially designed for searching faster and not linear.  Skipping thru parts of data so less time needed.

```C
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct node {
  int val;
  struct node *left;
  struct node *right;
} NODE;

NODE *createNode(int val) {
  NODE *newNode = malloc(sizeof(NODE));
  newNode->val = val;
  newNode->left = NULL;
  newNode->right = NULL;
  return newNode;
}

// NLR
void preorder(NODE *root) {
  if (root == NULL)
    return;

  printf("%d ", root->val);
  preorder(root->left);
  preorder(root->right);
}

// LNR
void inorder(NODE *root) {
  if (root == NULL)
    return;

  inorder(root->left);
  printf("%d ", root->val);
  inorder(root->right);
}

// LRN
void postorder(NODE *root) {
  if (root == NULL)
    return;

  postorder(root->left);
  postorder(root->right);
  printf("%d ", root->val);
}

void destroyTree(NODE *root) {
  if (root == NULL)
    return;
  NODE *leftTree = root->left;
  NODE *rightTree = root->right;
  free(root);
  destroyTree(leftTree);
  destroyTree(rightTree);
}

int main() {
  NODE *root = createNode(1);
  root->left = createNode(2);
  root->right = createNode(3);

  root->left->left = createNode(4);
  root->left->right = createNode(5);

  root->right->left = createNode(6);
  root->right->right = createNode(7);

  root->left->left->left = createNode(8);
  root->left->left->right = createNode(9);

  root->left->right->left = createNode(10);
  root->left->right->right = createNode(11);

  root->left->left->left->left = createNode(12);
  root->left->left->left->right = createNode(13);

  printf("Preorder\n");
  preorder(root);
  printf("\n");

  printf("Inorder\n");
  inorder(root);
  printf("\n");

  printf("Postrder\n");
  postorder(root);
  printf("\n");

  // printf("levelorder\n");
  // levelorder(root);
  // printf("\n");
}
```


### Binary search trees
1. One root node
2. All nodes left to root is < root->val
3. All nodes right to root is > root->val
4. Left and right sub-trees of root are also BSTs
5. A well height balanced BST is of the complexity log(N)
6. Inorder (LNR) gives sorted array
7. Leftmost node is the minimum value of tree
8. Rightmost node is the maximum value of tree
