Initially designed for searching faster and not linear.  Skipping thru parts of data so less time needed.

```C
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct node {
  int val;
  struct node *left;
  struct node *right;
} NODE;

NODE *createNode(int val) {
  NODE *newNode = malloc(sizeof(NODE));
  newNode->val = val;
  newNode->left = NULL;
  newNode->right = NULL;
  return newNode;
}

// NLR
void preorder(NODE *root) {
  if (root == NULL)
    return;

  printf("%d ", root->val);
  preorder(root->left);
  preorder(root->right);
}

// LNR
void inorder(NODE *root) {
  if (root == NULL)
    return;

  inorder(root->left);
  printf("%d ", root->val);
  inorder(root->right);
}

// LRN
void postorder(NODE *root) {
  if (root == NULL)
    return;

  postorder(root->left);
  postorder(root->right);
  printf("%d ", root->val);
}

void destroyTree(NODE *root) {
  if (root == NULL)
    return;
  NODE *leftTree = root->left;
  NODE *rightTree = root->right;
  free(root);
  destroyTree(leftTree);
  destroyTree(rightTree);
}

int main() {
  NODE *root = createNode(1);
  root->left = createNode(2);
  root->right = createNode(3);

  root->left->left = createNode(4);
  root->left->right = createNode(5);

  root->right->left = createNode(6);
  root->right->right = createNode(7);

  root->left->left->left = createNode(8);
  root->left->left->right = createNode(9);

  root->left->right->left = createNode(10);
  root->left->right->right = createNode(11);

  root->left->left->left->left = createNode(12);
  root->left->left->left->right = createNode(13);

  printf("Preorder\n");
  preorder(root);
  printf("\n");

  printf("Inorder\n");
  inorder(root);
  printf("\n");

  printf("Postrder\n");
  postorder(root);
  printf("\n");

  // printf("levelorder\n");
  // levelorder(root);
  // printf("\n");
}
```